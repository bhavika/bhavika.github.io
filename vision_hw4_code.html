<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title> Bhavika Tekwani </title>
  <meta name="description" content="Personal website, portfolio, bio">
  <meta name="author" content="Bhavika Tekwani">

  <script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js"></script>

  <!-- Mobile Specific Metas
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <!-- Font Awesome Social Icons -->
  <link rel="stylesheet" href="./font-awesome-4.7.0/css/font-awesome.min.css">
  <link href="//fonts.googleapis.com/css?family=Raleway:400,300,600" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="css/normalize.css">
  <link rel="stylesheet" href="css/skeleton.css">
  <link rel="stylesheet" href="css/bhavikatekwani.css">

</head>

<body>
    <h5> Assignment 4 </h5>
    <h6> There are 4 program files - part1_2.py, part3.py, part4.py, part5.py displayed below.</h6>
    <h5> part1_2.py </h5>

    <pre class="prettyprint">
                import cv2
                import glob
                import numpy as np
                import matplotlib.pyplot as plt
                import pandas as pd


                def viz(h, w, contours, hierarchy, title, poly=None, hull=None, defects=None):
                """
                Visualizes any combination of contours, polygonal approximation, convex hulls and defects on the
                original image.
                Saves all output images in a folder.
                Poly, hull and defects are optional to allow turning off what needs to be plotted at a time.
                :param h: int, height of the output image
                :param w: int, width of the output image
                :param contours: numpy array, contours
                :param hierarchy: list, hierarchy for each returned contour
                :param title: image title
                :param poly: numpy array, polygonal approximation of contours, default: None
                :param hull: numpy array, convex hull of contours, default: None
                :param defects: list, convexity defects, default: None
                :return: None
                """
                title = title[11:]
                cnt = contours[0]
                vis_placeholder = np.zeros((h+5, w+5, 3), np.uint8)

                if defects is not None:
                for i in range(defects.shape[0]):
                  s, e, f, d = defects[i, 0]
                  far = tuple(cnt[f][0])
                  cv2.circle(vis_placeholder, far, 2, [200, 200, 40], -1)

                if hull is not None: # red
                cv2.drawContours(vis_placeholder, hull, -1, (255, 0, 0), 1, cv2.LINE_AA, hierarchy, 0)

                if poly:
                # blue
                cv2.drawContours(vis_placeholder, poly, -1, (0, 0, 155), 1, cv2.LINE_AA, hierarchy, 0)

                # pink - contours
                cv2.drawContours(vis_placeholder, contours, -1, (234, 22, 129), 1, cv2.LINE_AA, hierarchy, maxLevel=2)
                plt.imshow(vis_placeholder)
                plt.title(title)
                plt.savefig('output/defects/'+title)


                def viz_moments(h, w, contours, hierarchy, title, hull, img_centroids, hull_centroids):
                title = title[11:]
                vis_placeholder = np.zeros((h + 5, w + 5, 3), np.uint8)

                if hull is not None:  # red
                cv2.drawContours(vis_placeholder, hull, -1, (255, 0, 0), 1, cv2.LINE_AA, hierarchy, 0)

                # green - contours
                cv2.drawContours(vis_placeholder, contours, -1, (0, 255, 0), 1, cv2.LINE_AA, hierarchy, maxLevel=2)
                cv2.circle(vis_placeholder, (img_centroids[0], img_centroids[1]), 2, (255, 255, 255), -1)
                cv2.circle(vis_placeholder, (hull_centroids[0], hull_centroids[1]), 2, (0, 125, 255), -1)
                plt.imshow(vis_placeholder)
                plt.title(title)
                plt.savefig('output/moments/' + title)


                def silhouette_features(images):
                features = {}

                for i in images:
                img = cv2.imread(i)
                h, w = img.shape[:2]
                img = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

                thresh, im_bw = cv2.threshold(img, 127, 255, cv2.THRESH_BINARY)
                _, contours0, hierarchy = cv2.findContours(im_bw, cv2.RETR_CCOMP, cv2.CHAIN_APPROX_SIMPLE)
                poly = [cv2.approxPolyDP(cnt, 3, True) for cnt in contours0]
                hull = [cv2.convexHull(cnt, clockwise=True) for cnt in contours0]


                try:
                  ctr = np.array(contours0).reshape((-1, 1, 2))
                  hull2 = cv2.convexHull(ctr, clockwise=True, returnPoints=False)
                  defects = cv2.convexityDefects(ctr, hull2)

                  # viz(h, w, contours=contours0, hierarchy=hierarchy, title=i, poly=None, hull=hull, defects=defects)

                  key = i[11:]
                  features[key] = {}

                  n_defects = len(defects) if defects is not None else 0

                  for n, cnt in enumerate(contours0):
                      contourArea = cv2.contourArea(cnt, oriented=False)
                      contourPerimeter = cv2.arcLength(cnt, True)
                      moments_contour = cv2.moments(cnt)

                      m00_img = moments_contour.get('m00', 0)
                      if m00_img != 0:
                          cx_img = int(moments_contour.get('m10', 0) / m00_img)
                          cy_img = int(moments_contour.get('m01', 0) / m00_img)
                      else:
                          cx_img, cy_img = 0, 0

                      features[key][n] = {}
                      features[key][n]['contour_area'] = contourArea
                      features[key][n]['contour_perimeter'] = contourPerimeter
                      features[key][n]['moments1_contour'] = [moments_contour.get('m10', 0), moments_contour.get('m01', 0)]
                      features[key][n]['moments2_contour'] = [moments_contour.get('mu20', 0), moments_contour.get('mu02', 0),
                                                              moments_contour.get('mu11', 0)]
                      features[key][n]['img_centroid'] = (cx_img, cy_img)

                  for n, hl in enumerate(hull):
                      hullArea = cv2.contourArea(hl, oriented=False)
                      hullPerimeter = cv2.arcLength(hl, closed=True)
                      moments_hull = cv2.moments(hl)

                      m00_hull = moments_hull.get('m00', 0)
                      if m00_hull != 0:
                          cx_hull = int(moments_hull.get('m10', 0) / m00_hull)
                          cy_hull = int(moments_hull.get('m01', 0) / m00_hull)
                      else:
                          cx_hull, cy_hull = 0, 0

                      features[key][n]['hull_area'] = hullArea
                      features[key][n]['hull_perimeter'] = hullPerimeter
                      features[key][n]['moments1_hull'] = [moments_hull.get('m10', 0), moments_hull.get('m01', 0)]
                      features[key][n]['moments2_hull'] = [moments_hull.get('m20', 0), moments_hull.get('mu02', 0),
                                                           moments_hull.get('mu11', 0)]
                      features[key][n]['defects'] = n_defects
                      features[key][n]['hull_centroid'] = (cx_hull, cy_hull)

                  features[key][n]['defects_area'] = features[key]['hull_area'] - features[key]['contour_area']

                  viz_moments(h, w, contours=contours0, hierarchy=hierarchy, title=i, hull=hull, img_centroids=(cx_img, cy_img),
                              hull_centroids=(cx_hull, cy_hull))


                # hierarchy exists
                except:
                  ctr1 = np.array(contours0[0])
                  ctr1 = ctr1.reshape((-1, 1, 2))
                  h2 = cv2.convexHull(ctr1, clockwise=True, returnPoints=False)
                  defects = cv2.convexityDefects(ctr1, h2)

                  # viz(h, w, contours=contours0, hierarchy=hierarchy, title=i, poly=None, hull=hull, defects=defects)

                  key = i[11:]
                  features[key] = {}

                  for k in range(len(contours0)):

                      c = np.array(contours0[k]).reshape((-1, 1, 2))
                      contourArea = cv2.contourArea(c, oriented=False)
                      contourPerimeter = cv2.arcLength(c, True)
                      moments_contour = cv2.moments(c)

                      hl = cv2.convexHull(c, clockwise=True, returnPoints=False)

                      moments_hull = cv2.moments(cv2.convexHull(c, clockwise=True, returnPoints=True))
                      hullArea = cv2.contourArea(cv2.convexHull(c, clockwise=True, returnPoints=True), oriented=False)
                      hullPerimeter = cv2.arcLength(cv2.convexHull(c, clockwise=True, returnPoints=True), closed=True)

                      defs = cv2.convexityDefects(c, hl)
                      n_defects = len(defs) if defs is not None else 0

                      m00_hull = moments_hull.get('m00', 0)
                      if m00_hull != 0:
                          cx_hull = int(moments_hull.get('m10', 0) / m00_hull)
                          cy_hull = int(moments_hull.get('m01', 0) / m00_hull)
                      else:
                          cx_hull, cy_hull = 0, 0

                      m00_img = moments_contour.get('m00', 0)
                      if m00_img != 0:
                          cx_img = int(moments_contour.get('m10', 0) / m00_img)
                          cy_img = int(moments_contour.get('m01', 0) / m00_img)
                      else:
                          cx_img, cy_img = 0, 0

                      features[key][k] = {}
                      features[key][k]['contour_area'] = contourArea
                      features[key][k]['contour_perimeter'] = contourPerimeter
                      features[key][k]['moments1_hull'] = [moments_hull.get('m10', 0), moments_hull.get('m01', 0)]
                      features[key][k]['moments2_hull'] = [moments_hull.get('mu20', 0), moments_hull.get('mu02', 0)]
                      features[key][k]['moments1_contour'] = [moments_contour.get('m10', 0), moments_contour.get('m01', 0)]
                      features[key][k]['moments2_contour'] = [moments_contour.get('mu20', 0), moments_contour.get('mu02', 0),
                                                              moments_contour.get('mu11', 0)]
                      features[key][n]['img_centroid'] = (cx_img, cy_img)
                      features[key][k]['hull_area'] = hullArea
                      features[key][k]['hull_perimeter'] = hullPerimeter
                      features[key][k]['defects'] = n_defects
                      features[key][k]['defects_area'] = hullArea - contourArea
                      features[key][n]['hull_centroid'] = (cx_hull, cy_hull)

                      viz_moments(h, w, contours=contours0, hierarchy=hierarchy, title=i, hull=hull,
                                  img_centroids=(cx_img, cy_img),
                                  hull_centroids=(cx_hull, cy_hull))

                return features


                def create_table(features):
                headers = ['Frame', 'Contour', 'contour_perimeter', 'moments2_hull', 'hull_area', 'hull_perimeter', 'moments1_hull',
                     'defects', 'contour_area', 'moments2_contour', 'defects_area', 'moments1_contour']

                df = pd.DataFrame(columns=headers)

                for k, v in features.items():
                for contour, features in v.items():
                  values = {'Frame': k, 'Contour': contour}
                  for key, val in features.items():
                      values[key] = val
                  df = df.append(values, ignore_index=True)

                df.to_csv('output/features.csv', header=True, sep=';', mode='w', index=False)


                def main():
                filenames = [img for img in glob.glob("GaitImages/*.png")]
                filenames.sort()
                features = silhouette_features(filenames)
                create_table(features)


                if __name__ == '__main__':
                main()
    </pre>

    <h5> part3.py </h5>
    <pre>
          import cv2
          import numpy as np
          import glob
          import matplotlib.pyplot as plt
          from scipy.signal import argrelextrema


          # contours is a list of lists of numpy arrays
          def get_contours(i):
          img = cv2.imread(i)
          h, w = img.shape[:2]
          img = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
          _, contours, hierarchy = cv2.findContours(img.copy(), cv2.RETR_LIST, cv2.CHAIN_APPROX_NONE)
          return contours


          # calculates the curvature at each point of the contour
          def curvature(contour, k=3):
          c = [0] * len(contour)

          for i in range(len(contour)):
              pts = i + k
              if pts >= len(contour):
                  diff = len(contour) - pts
                  pts -= diff

              if pts >= len(contour):
                  break

              # pick k points before and after the ith point
              x = [contour[i][0][0], contour[i-k][0][0], contour[pts][0][0]]
              y = [contour[i][0][1], contour[i-k][0][1], contour[pts][0][1]]

              eq1 = np.array([[1, 0, 0], [1, 1, 1], [1, 2, 4]])
              x = np.array(x)
              a = np.linalg.solve(eq1, x)

              eq2 = np.array([[1, 0, 0], [1, 1, 1], [1, 2, 4]])
              y = np.array(y)
              b = np.linalg.solve(eq2, y)

              k_i = 2*(a[1]*b[2]-b[1]*a[2])/(a[1]**2 + b[1]**2) ** 1.5
              c[i] = k_i

          return c


          def create_viz(i):
          img = cv2.imread(i)
          h, w = img.shape[:2]
          filename = i[11:]

          contours = get_contours(i)
          local_max = []

          if len(contours) > 1:
              x = []
              y = []
              K = []

              for cnt in contours:
                  curv = curvature(contour=cnt)
                  lmax = argrelextrema(np.array(curv), np.greater)[0]
                  if lmax.shape[0] != 0:
                      local_max.append(cnt[lmax[0]])

                  cmin = min(curv)
                  cmax = max(curv)

                  # scaling
                  curv_scaled = [255 * (c-cmin)/(cmax-cmin) for c in curv]
                  K.extend(curv_scaled)
                  temp1 = [cnt[i][0][0] for i in range(len(cnt))]
                  temp2 = [cnt[i][0][1] for i in range(len(cnt))]
                  x.extend(temp1)
                  y.extend(temp2)

              plt.title(filename)
              imgplt = plt.imshow(img)
              plt.scatter(x, y, c=K, marker=',', cmap='PuRd')
              for i in range(len(local_max)):
                  plt.scatter(x=local_max[0][0][0], y=local_max[0][0][1], marker="^", label='max', c="g")
              plt.ylim(128, 0)
              plt.savefig('output/curvature/' + filename)
              plt.clf()

          elif len(contours) == 1:
              local_max = []
              cnt = contours[0]
              curv = curvature(contour=cnt)
              cmin = min(curv)
              cmax = max(curv)

              lmax = argrelextrema(np.array(curv), np.greater)[0]

              if lmax.shape[0] != 0:
                  local_max.append(cnt[lmax[0]])

              # scaling
              K = [255 * (c - cmin) / (cmax - cmin) for c in curv]
              l = [cnt[i][0][0] for i in range(len(cnt))]
              m = [cnt[i][0][1] for i in range(len(cnt))]

              plt.title(filename)
              imgplt = plt.imshow(img)
              plt.scatter(l, m, c=K, marker=',', cmap='PuRd')
              for i in range(len(local_max)):
                  plt.plot(local_max[0][0][0], local_max[0][0][1], marker="^", label='max', c="g")
              plt.xlim(0, 88)
              plt.ylim(128, 0)
              plt.savefig('output/curvature/' + filename)
              plt.clf()

          if __name__ == '__main__':
          filenames = [img for img in glob.glob("GaitImages/*.png")]
          filenames.sort()

          for f in filenames:
              create_viz(f)
    </pre>

    <h5> part4.py </h5>
    <pre>
      import cv2
      import glob
      import matplotlib.pyplot as plt


      if __name__ == '__main__':
        filenames = [img for img in glob.glob("GaitImages/*.png")]
        filenames.sort()

        for f in filenames:
            img = cv2.imread(f, 0)
            h, w = img.shape[:2]

            f = f[11:]

            ret, thresh_img = cv2.threshold(img, 1, 255, cv2.THRESH_BINARY)
            dst = cv2.distanceTransform(thresh_img, distanceType=cv2.DIST_L2, maskSize=cv2.DIST_MASK_3)

            plt.imshow(dst, cmap='gray')
            plt.title(f)
            plt.savefig('output/dt/' + f)
            plt.clf()
    </pre>

    <h5> part5.py </h5>
    <pre>
        

    </pre>


    <h5> sedt.py </h5>
    <pre>
      import cv2
      import numpy as np
      import matplotlib.pyplot as plt


      #  Distance Transform across 1D
      def dt_1d(f, n):
          """
          Computes the Distance Transform across one dimension according to
          Felzenszwalb & Huttenlocher - http://www.cs.cornell.edu/~dph/papers/dt.pdf.
          :param f: 1D numpy array
          :param n: height/width of the image
          :return: 1D numpy array
          """
          output = np.zeros(f.shape)
          k = 0
          v = np.zeros((n,))
          z = np.zeros((n + 1,))
          v[0] = 0
          z[0] = -np.inf
          z[1] = +np.inf

          for q in range(1, n):
              v_k = v[k].astype(int)
              s = (((f[q] + q * q) - (f[v_k] + v[k] * v[k])) / (2.0 * q - 2.0 * v[k]))

              while s <= z[k]:
                  k -= 1
                  s = (((f[q] + q * q) - (f[v_k] + v[k] * v[k])) / (2.0 * q - 2.0 * v[k]))
              k += 1
              v[k] = q
              z[k] = s
              z[k + 1] = +np.inf

          k = 0
          for q in range(n):
              v_k = v[k].astype(int)
              while z[k + 1] < q:
                  k += 1
              distance = ((q - v[k]) * (q - v[k]) + f[v_k])

              if distance > 255:
                  distance = 255
              if distance < 0:
                  distance = 0
              output[q] = distance

          return output


      def distance_transform(image):
          height, width = image.shape
          output = np.zeros((height, width))

          # columns
          for x in range(width):
              f = image[:, x]
              output[:, x] = dt_1d(f, height)

          # rows
          for y in range(height):
              f = image[y, :]
              output[y, :] = dt_1d(f, width)
          return output


      if __name__ == '__main__':
          i = 'GaitImages/00000048.png'
          img = cv2.imread(i, 0)
          h, w = img.shape[:2]

          ret, thresh_img = cv2.threshold(img, 1, 500, cv2.THRESH_BINARY)

          dst = cv2.distanceTransform(thresh_img, distanceType=cv2.DIST_L2, maskSize=cv2.DIST_MASK_PRECISE)

          op = distance_transform(thresh_img)

          plt.imshow(dst, cmap='binary')
          plt.show()

          plt.imshow(op, cmap='gray')
          plt.show()



    </pre>


</body>
